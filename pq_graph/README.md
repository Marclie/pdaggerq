![pq_graph Logo](./pq_graph.png)
# PQ-Graph: Module for pdaggerq

pq_graph is an extension of the pdaggerq package, introducing graph-theoretical techniques to optimize many-body equations generated by pdaggerq. pq_graph will automatically generate intermediates and reorder expressions to minimize the number of floating point operations required to evaluate the equations. The module will generate code to evaluate these expressions using either Python with [Numpy](https://numpy.org/)
or C++ with [TiledArray](https://valeevgroup.github.io/tiledarray/dox-master/index.html).

The expressions are stored in data structures that represent tensor contractions as [directed graphs](https://en.wikipedia.org/wiki/Quiver_(mathematics)), with tensors represented by vertices. The edges of the graph represent the indices of the tensors, and the contraction of the tensors is represented by the connection of the edge. This representation is analyzed to determine the optimal order of contraction and can generate the graph in a format that can be visualized using [Graphviz](https://graphviz.org/).

This module is designed to be used in conjunction with pdaggerq, and is not intended to be used as a standalone package.

## Python API usage

```python
import pdaggerq
pq = pdaggerq.pq_helper('fermi')

# set up pq_graph
graph = pdaggerq.pq_graph({
    "verbose": True,                # print out verbose analysis?
    "max_temps": -1,                # maximum number of intermediates to find
    "prune_tmps": False,            # prune unused intermediates?
    "max_depth": 2,                 # maximum depth for chain of contractions
    "max_shape": {'o':255,'v':255}, # a map of intermediate maximum sizes
    "allow_nesting": True,          # allow nested intermediates?
    "permute_eri": True,            # permute ERI integrals to a common order?
    "format_sigma": True,           # format equations for a sigma-build?
    "batched": True,                # substitute intermediates in batches?
    "batch_size": 100,              # batch size for substitution
    "allow_merge": False,           # merge similar terms during optimization?
    "nthreads": 12,                 # number of threads to use for optimization
})

# singles block of CCSD: 0 = < 0 | i* a e(-T) H e(T) | 0>
pq.set_left_operators([['e1(i,a)']])
pq.add_st_operator(1.0,['f'],['t1','t2'])
pq.add_st_operator(1.0,['v'],['t1','t2'])
pq.simplify()

# queue up the singles equation for optimization
#   pass the pq_helper object and the name of the equation.
#   the name is used to label the left-hand side (lhs) of the equation
#   the last argument (optional) overrides the ordering of the lhs indices
graph.add(pq, "singles_residual", ['a', 'i'])
pq.clear() # reset pq_helper

# doubles block of CCSD: 0 = < 0 | i* j* b a e(-T) H e(T) | 0>
pq.set_left_operators([['e2(i,j,b,a)']])
pq.add_st_operator(1.0,['f'],['t1','t2'])
pq.add_st_operator(1.0,['v'],['t1','t2'])
pq.simplify()

# queue up the doubles equation for optimization
graph.add(pq, "doubles_residual", ['a', 'b', 'i', 'j'])
pq.clear() # reset pq_helper


graph.optimize()            # optimize the equations
graph.print("python")       # print the optimized equations for Python.
graph.analysis()            # prints the summary of the optimizations
graph.write_dot("ccsd.dot") # create a DOT file for Graphviz
```
