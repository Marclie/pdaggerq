![pq_graph Logo](./pq_graph.png)
# PQ-Graph: Module for pdaggerq

pq_graph is an extension of the pdaggerq package, introducing graph-theoretical techniques to optimize many-body equations generated by pdaggerq. pq_graph will automatically generate intermediates and reorder expressions to minimize the number of floating point operations required to evaluate the equations. The module will generate code to evaluate these expressions using either Python with [Numpy](https://numpy.org/)
or C++ with [TiledArray](https://valeevgroup.github.io/tiledarray/dox-master/index.html).

The expressions are stored in data structures that represent tensor contractions as [directed graphs](https://en.wikipedia.org/wiki/Quiver_(mathematics)), with tensors represented by vertices. The edges of the graph represent the indices of the tensors, and the contraction of the tensors is represented by the connection of the edge. This representation is analyzed to determine the optimal order of contraction and can generate the graph in a format that can be visualized using [Graphviz](https://graphviz.org/). 

This module is designed to be used in conjunction with pdaggerq, and is not intended to be used as a standalone package.

## Python API usage

```python
import pdaggerq as pq

# Initialize pq_graph
graph = pq.pq_graph()

# set options
graph.set_options({
    'verbose': True,
    'output': 'c++', # or 'python`
    'num_threads': 4,
    # ... refer to output from this command for more options
})

# generate an expression from pdaggerq
pq = pdaggerq.pq_helper("fermi")

# singles expression in CCSD
pq.set_left_operators([['e1(i,a)']])
pq.add_st_operator(1.0,['f'],['t1','t2'])
pq.add_st_operator(1.0,['v'],['t1','t2'])
pq.simplify()

# save expression to binary file (optional but recommended for reuse)
pq.save("singles.pq")

# add expression to graph
# note: the expression should be simplified before adding to the graph
# the first argument is the name of the expression and must include the
# indices of the expression (e.g. rt1(a,i) for the singles expression)
# the second argument is the expression itself from the pq module
graph.add("rt1(a,i)", pq)
pq.clear()

# ... add more expressions to the graph
pq.load("energy.pq") # load from binary file
graph.add("energy", pq)
pq.clear()

# ... add even MORE expressions to the graph
# ...
# ...


# print the initial output from the graph (not optimized)
graph.print()

# optimize the graph by reordering the expressions and creating intermediates
graph.optimize()

# print the optimized output from the graph
graph.print()

# Analyze optimization results 
# and generate a dot file for visualization of the expressions (optional, requires graphviz)
graph.analysis()
graph.write_dot("expression.dot")
```
