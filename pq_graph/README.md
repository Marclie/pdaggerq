<div align="center">
  <img src="./pq_graph.svg" width="400" alt="pq_graph Logo">
</div>

# PQ-Graph: Module for pdaggerq

pq_graph is an extension of the pdaggerq package, introducing graph-theoretical techniques to optimize many-body equations generated by pdaggerq. pq_graph will automatically generate intermediates and reorder expressions to minimize the number of floating point operations required to evaluate the equations. The module will generate code to evaluate these expressions using either Python with [Numpy](https://numpy.org/) or C++ with [TiledArray](https://valeevgroup.github.io/tiledarray/dox-master/index.html).

The expressions are stored in data structures that represent tensor contractions as [directed graphs](https://en.wikipedia.org/wiki/Quiver_(mathematics)), with tensors represented by vertices. The edges of the graph represent the indices of the tensors, and the contraction of the tensors is represented by the connection of the edge. This representation is analyzed to determine the optimal order of contraction and can generate the graph in a format that can be visualized using [Graphviz](https://graphviz.org/).

## Python API usage

#



```python
import pdaggerq

pq = pdaggerq.pq_helper("true")

print("# [u* v - u* v, H]")
pq.add_commutator( 1.0, [’a(u)*’, ’a(u)’], [’h’])
pq.add_commutator(-1.0, [’a(v)*’, ’a(v)’], [’h’])
pq.add_commutator( 0.5, [’a(u)*’, ’a(u)’], [’g’])
pq.add_commutator(-0.5, [’a(v)*’, ’a(v)’], [’g’])
pq.simplify()

graph = pdaggerq.pq_graph({

# verbosity level:
# 0: no printing of optimization steps (default)
# 1: print optimization steps without fusion or merging
# 2: print optimization steps with fusion and merging      
"print_level": 2,  
                       
# optimization level:
# 0: no optimization
# 1: single-term optimization only (reordering)
# 2: reordering and subexpression elimination (substitution)
# 3: reordering, substitution, and separation of reusable intermediates (for sigma vectors)
# 4: reordering, substitution, and separation; unused intermediates are removed (pruning)
# 5: reordering, substitution, separation, pruning, and merging of equivalent terms
# 6: reordering, substitution, separation, pruning, merging, and fusion of intermediates (default)
"opt_level": 6,                    

# whether to permute two-electron integrals to common order (default: true)                      
"permute_eri": True,  

# whether to skip the scalar terms in the final equations (default: false)
"no_scalars": False,  

# whether to store trial vectors as an additional index/dimension 
# for tensors in a sigma-vector build (default: false)
"use_trial_index": True, 

# whether to separate reusable intermediates for sigma-vector build (default: false)
"separate_sigma": True, 

# candidate substitutions are applied in batches rather than one at a time. (default: false)
# Generally faster, but may not yield optimal results compared to single substitutions.
"batched": False, 

# size of the batch for batched substitution (default: 10; -1 for no limit)
"batch_size": 10,

# maximum number of intermediates to find (default: -1 for no limit)
"max_temps": -1,  

# maximum depth for chain of contractions (default: -1 for no limit)
"max_depth": -1,  

# whether to recompute or save all permutations of each term in memory (default: false)
# if true, permutations are recomputed on the fly. Recommended if memory runs out.
"low_memory": False,  
                
# number of threads to use (default: OMP_NUM_THREADS | available cores if unset)
"nthreads": 12,
})

block_by_spin = False # use spin-blocking or not
if block_by_spin:
    # add alpha-alpha block
    pq.block_by_spin({"u": "a", "v": "a"})
    graph.add(pq, "grad_aa", ['u', 'v'])

    # add beta-beta block
    pq.block_by_spin({"u": "b", "v": "b"})
    graph.add(pq, "grad_bb", ['u', 'v'])
else:
    graph.add(pq, "grad", ['u', 'v'])

graph.optimize()
graph.print("python")
graph.analysis()

# create a DOT file for use with Graphviz
graph.write_dot("grad.dot") 
```
